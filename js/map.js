// Generated by CoffeeScript 1.6.3
(function() {
  var HexaMap;

  HexaMap = (function() {
    HexaMap.CLOSEST_CELLS = {
      0: {
        dx: 1,
        dy: -1
      },
      2: {
        dx: 1,
        dy: 0
      },
      4: {
        dx: 0,
        dy: 1
      },
      6: {
        dx: -1,
        dy: 1
      },
      8: {
        dx: -1,
        dy: 0
      },
      10: {
        dx: 0,
        dy: -1
      }
    };

    HexaMap.prototype.map = void 0;

    HexaMap.prototype.offset = void 0;

    function HexaMap(app, map) {
      var dh, dw, map_size;
      this.app = app;
      if (map == null) {
        map = void 0;
      }
      this._ = HexaMap;
      this.map = map || this.generateMap();
      map_size = this.getMapRect(this.map);
      dw = (this.app.c.width - map_size.width) * 0.5;
      dh = (this.app.c.height - map_size.height) * 0.5;
      this.offset = {
        x: -map_size.from.x + dw,
        y: -map_size.from.y + dh
      };
    }

    HexaMap.prototype.getCell = function(x, y) {
      if (this.map[y] && this.map[y][x] !== void 0) {
        return this.map[y][x];
      }
    };

    HexaMap.prototype.getMapRect = function(map) {
      var cell, ix, iy, p, row, x_max, x_min, y_max, y_min, _i, _j, _len, _len1;
      if (map == null) {
        map = void 0;
      }
      if (!map) {
        map = this.map;
      }
      x_min = y_min = x_max = y_max = 0;
      for (iy = _i = 0, _len = map.length; _i < _len; iy = ++_i) {
        row = map[iy];
        for (ix = _j = 0, _len1 = row.length; _j < _len1; ix = ++_j) {
          cell = row[ix];
          if (cell !== void 0) {
            p = cell.position(ix, iy);
            if (p.x < x_min) {
              x_min = p.x;
            }
            if (p.x > x_max) {
              x_max = p.x;
            }
            if (p.y < y_min) {
              y_min = p.y;
            }
            if (p.y > y_max) {
              y_max = p.y;
            }
          }
        }
      }
      return {
        from: {
          x: x_min,
          y: y_min
        },
        to: {
          x: x_max,
          y: y_max
        },
        width: x_max - x_min,
        height: y_max - y_min
      };
    };

    HexaMap.prototype.render = function() {
      return this.renderMap();
    };

    HexaMap.prototype.renderMap = function() {
      var cell, ix, iy, row, _i, _j, _len, _len1, _ref;
      _ref = this.map;
      for (iy = _i = 0, _len = _ref.length; _i < _len; iy = ++_i) {
        row = _ref[iy];
        for (ix = _j = 0, _len1 = row.length; _j < _len1; ix = ++_j) {
          cell = row[ix];
          if (cell !== void 0) {
            cell.render();
          }
        }
      }
    };

    HexaMap.prototype.countCells = function(map, val) {
      if (!map) {
        map = this.map;
      }
      return this._.countCells(map, val);
    };

    HexaMap.countCells = function(map, val) {
      var ans, cell, ix, iy, row, _i, _j, _len, _len1;
      ans = 0;
      for (iy = _i = 0, _len = map.length; _i < _len; iy = ++_i) {
        row = map[iy];
        for (ix = _j = 0, _len1 = row.length; _j < _len1; ix = ++_j) {
          cell = row[ix];
          if (map[iy][ix] === val) {
            ans++;
          }
        }
      }
      return ans;
    };

    HexaMap.prototype.waves = function(map, x, y) {
      if (!map) {
        map = this.map;
      }
      return this._.waves(map, x, y);
    };

    HexaMap.waves = function(map, x, y) {
      var cell, closest, clp, iter, ix, iy, row, wmap, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
      wmap = new Array(map.length);
      for (iy = _i = 0, _len = map.length; _i < _len; iy = ++_i) {
        row = map[iy];
        wmap[iy] = (new Array(map[iy].length)).fill(0);
      }
      wmap[y][x] = 1;
      iter = wmap.length * wmap[0].length;
      while (this.countCells(wmap, 0) && iter--) {
        for (iy = _j = 0, _len1 = wmap.length; _j < _len1; iy = ++_j) {
          row = wmap[iy];
          for (ix = _k = 0, _len2 = row.length; _k < _len2; ix = ++_k) {
            cell = row[ix];
            if (cell === 0) {
              closest = void 0;
              _ref = this.closestCells(map, ix, iy);
              for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
                clp = _ref[_l];
                if (!closest || (wmap[clp.y][clp.x] > 0 && closest > wmap[clp.y][clp.x])) {
                  closest = wmap[clp.y][clp.x];
                }
              }
              if (closest) {
                wmap[iy][ix] = closest + 1;
              }
            }
          }
        }
      }
      return wmap;
    };

    HexaMap.prototype.closestCells = function(map, x, y) {
      if (!map) {
        map = this.map;
      }
      return this._.closestCells(map, x, y);
    };

    HexaMap.closestCells = function(map, x, y) {
      var ans, closest, key, _ref;
      ans = [];
      _ref = this.CLOSEST_CELLS;
      for (key in _ref) {
        closest = _ref[key];
        if (map[y + closest.dy] && map[y + closest.dy][x + closest.dx] !== void 0) {
          ans.push({
            x: x + closest.dx,
            y: y + closest.dy
          });
        }
      }
      return ans;
    };

    HexaMap.prototype.getCell = function(x, y) {
      var _ref, _ref1;
      return (_ref = this.map) != null ? (_ref1 = _ref[y]) != null ? _ref1[x] : void 0 : void 0;
    };

    HexaMap.prototype.getCells = function(pos) {
      var ans, p, _i, _len;
      if (pos == null) {
        pos = [];
      }
      ans = [];
      for (_i = 0, _len = pos.length; _i < _len; _i++) {
        p = pos[_i];
        if (this.map[p.y] && this.map[p.y][p.x] !== void 0) {
          ans.push(this.map[p.y][p.x]);
        }
      }
      return ans;
    };

    HexaMap.prototype.getAllCells = function(map) {
      if (map == null) {
        map = void 0;
      }
      if (!map) {
        map = this.map;
      }
      return this._.getAllCells(map);
    };

    HexaMap.getAllCells = function(map) {
      var iy, row, shovel, _i, _len;
      shovel = [];
      for (iy = _i = 0, _len = map.length; _i < _len; iy = ++_i) {
        row = map[iy];
        shovel = shovel.concat(map[iy]);
      }
      return shovel.filter(function(cell) {
        return cell !== void 0;
      });
    };

    HexaMap.prototype.generateMap = function(size, rate, deep) {
      var cell, empty, ix, iy, map, pmap, rcell, row, temp, times, waves, _i, _j, _k, _l, _len, _len1;
      if (size == null) {
        size = 5;
      }
      if (rate == null) {
        rate = 0.8;
      }
      if (deep == null) {
        deep = 0;
      }
      map = [];
      for (iy = _i = 0; 0 <= size ? _i <= size : _i >= size; iy = 0 <= size ? ++_i : --_i) {
        temp = [];
        for (ix = _j = 0; 0 <= size ? _j <= size : _j >= size; ix = 0 <= size ? ++_j : --_j) {
          temp.push(Math.random() < rate ? new HexaCell(this.app, ix, iy) : void 0);
        }
        map.push(temp);
        pmap = this.map;
      }
      if (deep > 10) {
        return null;
      }
      times = 3;
      rcell = this._.getAllCells(map)[0];
      empty = size * size;
      if (rcell) {
        waves = this.waves(map, rcell.x, rcell.y);
        empty = this.countCells(waves, 0);
      }
      if (empty > size * size * rate * 0.5) {
        map = this.generateMap(size, rate, deep + 1);
      } else {
        for (iy = _k = 0, _len = waves.length; _k < _len; iy = ++_k) {
          row = waves[iy];
          for (ix = _l = 0, _len1 = row.length; _l < _len1; ix = ++_l) {
            cell = row[ix];
            if (cell === 0) {
              map[iy][ix] = void 0;
            }
          }
        }
      }
      return map;
    };

    return HexaMap;

  })();

  window.HexaMap = HexaMap;

}).call(this);
